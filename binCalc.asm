;=====================================================
; Simple Binary Calculator
; Group A16
; 	- Farhan Azyumardhi Azmi 		1706979234
;	- Muhammad Nadhirsyah Indra 	1706039383
;	- Siti Aulia Rahmatussyifa		1706022073
;=====================================================

;=====================================================
; Processor		: ATMega8515
; Compiler		: AVRASM
;=====================================================

;=====================================================
; KNOWN ISSUE (?)
; - Register can only hold up to 127 signed decimal from input
;	Ex: 1111 1111 is saved as 127 signed, because
;	S flag in SREG is turned on. Nevertheless,
;	the result of every operation can hold up to 255 unsigned 
;	decimal.
;=====================================================

;=====================================================
; DEFINITIONS
;=====================================================
.include "m8515def.inc"
.def temp = r16
.def PB	= r24			; PORTB
.def A = r25	
.def TEMPOPERAND = r18	; Stores temporary operand used in calculation
.def USEDOPERAND1 = r14	; Stores operand #1
.def USEDOPERAND2 = r19	; Stores operand #2
.def RESULT = r15		; Stores result of any operation
.def OPERATOR = r21		; Stores type of operation
.def NUMBEROFBIT = r22	; Stores number of bit
.def NEXTOPERATION = r17
.equ TIMECOUNTER = 155

;=====================================================
; RESET and INTERRUPT VECTORS
;=====================================================
.org 	$00
rjmp 	MAIN
.org 	$01
rjmp 	EXT_INT0
.org 	$02
rjmp	EXT_INT1
.org	$07
rjmp	ISR_TOV0


;=====================================================
; DELAYS
;=====================================================
DELAY_00:
	; Generated by delay loop calculator
	; at http://www.bretmulvey.com/avrdelay.html
	;
	; Delay 4 000 cycles
	; 500us at 8.0 MHz

	    ldi 	r18, 6
	    ldi 	r19, 49
	L0: dec		r19
	    brne 	L0
	    dec  	r18
	    brne 	L0
	ret

DELAY_01:
	; Generated by delay loop calculator
	; at http://www.bretmulvey.com/avrdelay.html
	;
	; DELAY_CONTROL 40 000 cycles
	; 5ms at 8.0 MHz

	    ldi  	r18, 52
	    ldi  	r19, 242
	L1: dec  	r19
	    brne 	L1
	    dec  	r18
	    brne 	L1
	    nop
	ret

DELAY_02:
; Generated by delay loop calculator
; at http://www.bretmulvey.com/avrdelay.html
;
; Delay 160 000 cycles
; 20ms at 8.0 MHz

	    ldi  	r18, 208
	    ldi  	r19, 202
	L2: dec  	r19
	    brne 	L2
	    dec  	r18
	    brne 	L2
	    nop
		ret

;=====================================================
; CODE SEGMENT
;=====================================================
MAIN:
	cbi 	PORTA,	1	; Reg. Select Pin = 0
	ldi 	PB, $01
	out 	PORTB, PB
	sbi		PORTA, 0	; Enable Pin = 1
	cbi 	PORTA, 0	; Enable Pin = 0

INIT_STACK:
	ldi 	temp, low(RAMEND)
	out 	SPL, temp
	ldi 	temp, high(RAMEND)
	out 	SPH, temp

INIT_BUTTONS:
	clr 	temp
	out 	DDRC, temp	; Set port C as input
	out 	DDRE, temp	; Set port E as input

INIT_INTERRUPT:
	ldi 	temp, 0b11000000
	out 	GICR, temp
	ldi 	temp, 0b00001010
	out 	MCUCR, temp

INIT_LCD_MAIN:
	rcall 	INIT_LCD

	ser 	temp
	out 	DDRA, temp	; Set port A as output
	out 	DDRB, temp	; Set port B as output
	
	rjmp 	INPUT_WELCOME

INIT_LCD:
	cbi 	PORTA, 1	; Reg. Select Pin = 0
	ldi 	PB, 0b00011100
	out 	PORTB, PB
	ldi 	PB, 0x38	; 8 bit, 2 line, 5x8 dots
	out 	PORTB,	PB
	sbi 	PORTA, 0	; Enable Pin = 1
	cbi 	PORTA, 0	; Enable Pin = 0
	;rcall DELAY_01
	cbi 	PORTA, 1	; Reg. Select Pin = 0
	ldi 	PB, 0b00001111	; Display ON, cursor ON, blink ON
	out 	PORTB, PB
	sbi 	PORTA, 0	; Enable Pin = 1
	cbi 	PORTA, 0	; Enable Pin = 0
	;rcall DELAY_01
	rcall 	CLEAR_LCD
	cbi 	PORTA, 1	; Reg. Select Pin = 0
	ldi 	PB, 0x06	; Increase cursor, display scroll OFF
	out 	PORTB, PB
	sbi 	PORTA, 0	; Enable Pin = 1
	cbi 	PORTA, 0	; Enable Pin = 0
	;rcall DELAY_01
	ret

INPUT_WELCOME:			; Write opening text to LCD
	ldi 	ZH, high(2*opening)
	ldi 	ZL, low(2*opening)

	rjmp 	LOADBYTE_OPENING

INPUT_CLOSING:
	ldi		ZH, high(2*closing)
	ldi		ZL, low(2*closing)

	rjmp	LOADBYTE_CLOSING

LOADBYTE_OPENING:
	lpm 				; Load byte from program memory to r0
	
	tst		r0			; Check if we've reached the end of the message
	breq 	DELAY_CALL

	mov 	A, r0		; Put the character into Port B
	rcall 	WRITE_TEXT
	adiw 	ZL, 1		; Increment Z registers
	rjmp 	LOADBYTE_OPENING

LOADBYTE_CLOSING:
	lpm

	tst		r0
	breq	EXIT

	mov		A, r0
	rcall	WRITE_TEXT_CLOSING
	adiw	ZL, 1
	rjmp	LOADBYTE_CLOSING

WRITE_TEXT:				; Output text
	sbi 	PORTA, 1	; Reg. Select Pin = 1
	out 	PORTB, A	
	sbi 	PORTA, 0	; Enable Pin = 1
	cbi 	PORTA, 0	; Enable Pin = 0
	;rcall DELAY_01
	ret

WRITE_TEXT_CLOSING:
	sbi		PORTA, 1
	out		PORTB, A
	sbi		PORTA, 0
	cbi		PORTA, 0
	ret

CLEAR_LCD:
	cbi 	PORTA, 1	; Reg. Select Pin = 0
	ldi 	PB, 0x01
	out 	PORTB, PB
	sbi 	PORTA, 0	; Enable Pin = 1
	cbi 	PORTA, 0	; Enable Pin = 0
	;rcall DELAY_01
	ret

DELAY_CALL:
	rcall	INIT_TIMER

	;rcall DELAY_02
	rcall 	CLEAR_LCD
	rcall 	CURSOR_SHIFT_LEFT
	;rcall DELAY_02
	rjmp 	ACTIVATE_SEI

INIT_TIMER:
	ldi		r23, TIMECOUNTER

	ldi		temp, (1<<CS02)
	out		TCCR0, temp
	ldi		temp, (1<<TOV0)
	out		TIFR, temp
	ldi		temp, (1<<TOIE0)
	out		TIMSK, temp
	ret
	

ACTIVATE_SEI:
	sei
	rjmp	EXIT

EXIT:	
	in 		temp, PINC

	;cpi	temp, 0b00000001
	;breq	DELETE_BIT

	cpi		temp, 0b00000010	; Check if "CLEAR" button is pressed
	breq	CLEAR_ALL	

	cpi 	temp, 0b00000100	; Check if "+" button is pressed
	breq 	ACTIVATE_TAMBAH_LED

	cpi 	temp, 0b00001000	; Check if "-" button is pressed
	breq 	ACTIVATE_KURANG_LED

	cpi 	temp, 0b00010000	; Check if "x" button is pressed
	breq 	ACTIVATE_KALI_LED

	cpi 	temp, 0b00100000	; Check if "/" button is pressed
	breq 	ACTIVATE_BAGI_LED

	cpi 	temp, 0b01000000	; Check if "CALCULATE" button is pressed
	breq 	PROCEED_CALCULATE

	rjmp 	EXIT

;DELETE_BIT:
	;rcall	CURSOR_SHIFT_RIGHT
	;rjmp	EXIT
	

CLEAR_ALL:
	rcall 	CLEAR_DATA
	rcall	CLEAR_LCD
	rcall	CURSOR_SHIFT_LEFT
	rjmp	EXIT

CLEAR_DATA:
	clr		USEDOPERAND1
	clr		USEDOPERAND2
	clr		RESULT
	clr		NUMBEROFBIT
	clr		r20
	clr		NEXTOPERATION
	ret

ACTIVATE_TAMBAH_LED:
	rcall	INIT_TIMER

	add 	USEDOPERAND1, USEDOPERAND2
	ldi 	temp, 0b00000001
	ldi 	OPERATOR, 1		; OPERATOR 1 = TAMBAH
	rjmp	ACTIVATE_LED

ACTIVATE_KURANG_LED:
	rcall	INIT_TIMER

	add 	USEDOPERAND1, USEDOPERAND2
	ldi 	temp, 0b00000010
	ldi 	OPERATOR, 2		; OPERATOR 2 = KURANG
	rjmp	ACTIVATE_LED

ACTIVATE_KALI_LED:
	rcall	INIT_TIMER

	add 	USEDOPERAND1, USEDOPERAND2
	ldi 	temp, 0b00000100
	ldi 	OPERATOR, 3		; OPERATOR 3 = KALI
	rjmp	ACTIVATE_LED

ACTIVATE_BAGI_LED:
	rcall	INIT_TIMER

	add 	USEDOPERAND1, USEDOPERAND2
	ldi 	temp, 0b00001000
	ldi 	OPERATOR, 4		; OPERATOR 4 = BAGI
	rjmp	ACTIVATE_LED

ACTIVATE_LED:
	out		PORTE, temp
	ldi 	USEDOPERAND2, 0
	rcall	CLEAR_LCD
	rcall	CURSOR_SHIFT_LEFT
	ldi 	NUMBEROFBIT, 0

	cpi		NEXTOPERATION, 1	; Check if this is the next operation...
	breq	RESULT_TO_OPERAND1
	rjmp	EXIT

	RESULT_TO_OPERAND1:		; Set the previous result to operand #1 to be used next
		mov		USEDOPERAND1, RESULT
		rjmp	EXIT

PROCEED_CALCULATE:
	ldi 	temp, 0b00000000
	out 	PORTE, temp

	cpi 	OPERATOR, 0		; Check if there's no assigned operator
	breq 	EXIT
	
	cpi 	OPERATOR, 1		; Check if OPERATOR = TAMBAH
	breq 	CALCULATE_TAMBAH

	cpi 	OPERATOR, 2		; Check if OPERATOR = KURANG
	breq 	CALCULATE_KURANG

	cpi 	OPERATOR, 3		; Check if OPERATOR = KALI
	breq 	CALCULATE_KALI

	cpi 	OPERATOR, 4		; Check if OPERATOR = BAGI
	breq 	CALCULATE_BAGI	

CALCULATE_TAMBAH:
	ldi 	OPERATOR, 0
	mov 	RESULT, USEDOPERAND1
	add 	RESULT, USEDOPERAND2
	rjmp 	SHOW_RESULT

CALCULATE_KURANG:
	ldi 	OPERATOR, 0
	mov 	RESULT, USEDOPERAND1
	sub 	RESULT, USEDOPERAND2
	rjmp 	SHOW_RESULT

CALCULATE_KALI:
	ldi 	OPERATOR, 0
	mov 	RESULT, USEDOPERAND1
	mul 	RESULT, USEDOPERAND2
	mov 	RESULT, r0
	rjmp 	SHOW_RESULT

CALCULATE_BAGI:
	ldi 	OPERATOR, 0
	mov 	RESULT, USEDOPERAND1
	mov 	r3, USEDOPERAND1
	mov 	r4, USEDOPERAND2
	mov 	r5, RESULT
	rcall 	DIVIDE_ROUTINE
	mov 	RESULT, r0
	rjmp 	SHOW_RESULT

; Subroutine to divide two single-byte numbers
; Taken from https://sites.google.com/site/avrasmintro/home/2b-basic-math
; Registers used:
; - r0 to hold answer
; - r2 to hold remainder
; - r20 to hold bit counter
DIVIDE_ROUTINE:

	DIVIDE:
		ldi		r20, 9		; Load bit counter
		sub 	r2, r2		; Clear remainder and carry
		mov 	r0, r5
	LOOP:
		rol 	r0			; Shift the answer to the left
		dec 	r20	
		breq 	DONE
		rol 	r2			; Shift the remainder to the left
		sub 	r2, r4		; Subtract divisor from the remainder
		brcc 	SKIP		; If the result is negative...
		add 	r2, r4		; Reverse the subtraction to try again
		clc					; Clear Carry Flag so zero shifted in dividend
		rjmp 	LOOP
	SKIP:
		sec					; Set Carry Flag to be shifted into dividend
		rjmp 	LOOP
	DONE:
		ret

; Subroutine that displays the result of the operation to the LCD
SHOW_RESULT:
	rcall	CLEAR_LCD
	rcall 	CURSOR_SHIFT_LEFT
	
	ldi		NEXTOPERATION, 1
	ldi		NUMBEROFBIT, 9	; Load bit counter
	mov		r5, RESULT		; Set RESULT as dividend
	ldi		r20, 2			; Set 2 as divisor
	mov		r4,	r20
	
	LOOP_DIVIDE:
		dec		NUMBEROFBIT	
		brne	CHECK_REMAINDER
		rcall	INIT_TIMER
		rjmp	EXIT

	CHECK_REMAINDER:
		rcall	DIVIDE_ROUTINE
		mov		r5, r0		; Set the result of the division as dividend of the next loop
		mov		r20, r2		; Move the temporary remainder (modulo) 

		cpi		r20, 0		; If the modulo is 0...
		breq	OUTPUT_0	; Output 0 to the LCD

		cpi		r20, 1		; If the modulo is 1...
		breq	OUTPUT_1	; Output 1 to the LCD

	OUTPUT_0:
		sbi 	PORTA, 1		; Reg. Select Pin = 1
		cbi 	PORTA, 2		; Read/Write Pin = 0
		ldi 	PB, 0x30		; Write 0
		out 	PORTB, PB
		sbi 	PORTA, 0		; Enable Pin = 1
		cbi 	PORTA, 0		; Enable Pin = 0
		rcall	CURSOR_SHIFT_LEFT
		rjmp	LOOP_DIVIDE

	OUTPUT_1:
		sbi 	PORTA, 1		; Reg. Select Pin = 1
		cbi 	PORTA, 2		; Read/Write Pin = 0
		ldi 	PB, 0x31		; Write 1
		out 	PORTB, PB
		sbi 	PORTA, 0		; Enable Pin = 1
		cbi 	PORTA, 0		; Enable Pin = 0
		rcall	CURSOR_SHIFT_LEFT
		rjmp 	LOOP_DIVIDE

EXT_INT0:
	ldi 	r20, 1
	add 	NUMBEROFBIT, r20
	rcall 	WRITE_0
	rcall 	CURSOR_SHIFT_LEFT
	reti

WRITE_0:
	sbi 	PORTA, 1		; Reg. Select Pin = 1
	cbi 	PORTA, 2		; Read/Write Pin = 0
	ldi 	PB, 0x30		; Write 0
	out 	PORTB, PB
	sbi 	PORTA, 0		; Enable Pin = 1
	cbi 	PORTA, 0		; Enable Pin = 0
	ret
	
EXT_INT1:
	ldi 	TEMPOPERAND, 1
	add 	r20, NUMBEROFBIT
	cpi 	NUMBEROFBIT, 0	; Check if the input bit is the zero bit
	brne 	POWER_OF_TWO	; If not, add 2^n to OPERAND
	ldi 	USEDOPERAND2, 1
	rjmp 	WRITE_1

ISR_TOV0:
	dec		r23
	breq	THROW_TIMER
	reti

THROW_TIMER:
	rcall	INIT_LCD
	rcall	CLEAR_DATA
	rcall	INPUT_CLOSING
	cli
	rjmp	EXIT
	
; Subroutine to add 2^n to OPERAND if n > 1
POWER_OF_TWO:
	lsl 	TEMPOPERAND		; Multiply by two
	dec 	r20
	brne 	POWER_OF_TWO
	lsr 	TEMPOPERAND		; Divide by two
	add 	USEDOPERAND2, TEMPOPERAND
	rjmp 	WRITE_1

WRITE_1:
	clr 	TEMPOPERAND

	sbi 	PORTA, 1		; Reg. Select Pin = 1
	cbi 	PORTA, 2		; Read/Write Pin = 0
	ldi 	PB, 0x31		; Write 1
	out 	PORTB, PB
	sbi 	PORTA, 0		; Enable Pin = 1
	cbi 	PORTA, 0		; Enable Pin = 0

	ldi 	r20, 1
	add 	NUMBEROFBIT, r20

	rcall 	CURSOR_SHIFT_LEFT
	reti

CURSOR_SHIFT_LEFT:
	cbi 	PORTA, 1		; Reg. Select Pin = 0
	cbi 	PORTA, 2		; Read/Write Pin = 0
	ldi 	PB, 0b00010000 	; Shift cursor to the left
	out 	PORTB, PB
	sbi 	PORTA, 0		; Enable Pin = 1
	cbi 	PORTA, 0		; Enable Pin = 0
	;rcall DELAY_01

	cbi 	PORTA, 1
	cbi 	PORTA, 2
	ldi 	PB, 0b00011100	; Shift the entire display to the right
	out 	PORTB, PB
	sbi 	PORTA, 0
	cbi 	PORTA, 0
	;rcall DELAY_01

	cbi 	PORTA, 1		; Reg. Select Pin = 0
	cbi 	PORTA, 2		; Read/Write Pin = 0
	ldi 	PB, 0b00010000 	; Shift cursor to the left
	out 	PORTB, PB
	sbi 	PORTA, 0		; Enable Pin = 1
	cbi 	PORTA, 0		; Enable Pin = 0
	;rcall DELAY_01

	ret	

;CURSOR_SHIFT_RIGHT:
	;cbi 	PORTA, 1		; Reg. Select Pin = 0
	;cbi 	PORTA, 2		; Read/Write Pin = 0
	;ldi 	PB, 0b00010100 	; Shift cursor to the right
	;out 	PORTB, PB
	;sbi 	PORTA, 0		; Enable Pin = 1
	;cbi 	PORTA, 0		; Enable Pin = 0
	;ret
	

;=====================================================
; DATA
;=====================================================
opening:
.db "Welcome to Binary Calculator!", 0

closing:
.db	"BYE BYE!", 0
